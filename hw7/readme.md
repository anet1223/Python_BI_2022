# Functional.py

Скрипт содержит набор следующих функций:

-   **sequential_map** - функция принимает в качестве аргументов любое количество функций, а также контейнер с какими-то значениями. Функция возвращает список результатов последовательного применения переданных функций к значениям в контейнере. Например:

    ```{python}
    In[]: sequential_map(np.square, np.sqrt, lambda x: x**3, [1, 2, 3, 4, 5])
    Out[]: [1, 8, 27, 64, 125]
    ```

-   **consensus_filter** - функция принимает в качестве аргументов любое количество функций, возвращающих True или False, а также контейнер с какими-то значениями. Функция возвращает список значений, которые при передаче их во все функции дают True. Например:

    ```{python}
    In[]: consensus_filter(lambda x: x > 0, lambda x: x > 5, lambda x: x < 10, [-2, 0, 4, 6, 11]) 
    Out[]:[6]
    ```

-   **conditional_reduce** - функция принимает 2 функции, а также контейнер с значениями. Первая функция должна принимать 1 аргумент и возвращать True или False, вторая также принимает 2 аргумента и возвращает значение (как в обычной функции reduce). conditional_reduceвозвращает одно значение - результат reduce, пропуская значения с которыми первая функция выдала False. Например:

    ```{python}
    In[]:conditional_reduce(lambda x: x < 5, lambda x, y: x + y, [1, 3, 5, 10])
    Out[]:4
    ```

-   **func_chain** - функция принимает в качестве аргументов любое количество функций. Функция возвращает функцию, объединяющую все переданные последовательным выполнением. Например:

    ```{python}
    In[]:my_chain = func_chain(lambda x: x + 2, lambda x: (x/4, x//4))
         my_chain(37)
    Out[]:(9.75, 9)
    ```

-   **sequential_map2** - функция аналогичная функции sequential_map, только использует функцию func_chain внутри себя

-   **multiple_partial** - аналог функции **partial,** но принимает неограниченное число функций в качестве аргументов и возвращает список из такого же числа "частичных функций". Например:

    ```{python}
    In[]:ax1_mean, ax1_max, ax1_sum = multiple_partial(np.mean, np.max, np.sum, axis=1)
         arr = np.array([[1, 2, 3], [4, 5, 6]])
         ax1_mean(arr)
         ax1_max(arr)
         ax1_sum(arr)
    Out[]:array([2., 5.])
          array([3, 6])
          array([6, 15])
    ```
